<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="DRAW" id="0">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">if(owner.taunting)
    exit;
    
var imageOffset, xdrawpos, ydrawpos;
imageOffset = owner.team;
xdrawpos = round(x+xoffset*image_xscale);
ydrawpos = round(y+yoffset);
if(instance_exists(healTarget))
{
    if(healTarget.object != -1)
    {
        var color;
        if(healTarget.team == TEAM_RED)
            color = c_red;
        else
            color = c_blue;
        
        draw_set_alpha(0.3);
        var startx,starty,endx,endy,segments,lastx,lasty,dist,dir;
        startx = xdrawpos+lengthdir_x(24,owner.aimDirection);
        starty = ydrawpos+lengthdir_y(24,owner.aimDirection);
        endx = healTarget.object.x;
        endy = healTarget.object.y;
        dist = min(128,point_distance(startx,starty,endx,endy)*2);
        dir = owner.aimDirection + (cos(current_time/150)*3);
        segments = 20; //Change this to increase/decrease quality.
        lastx = startx;
        lasty = starty;
        for (i=0;i&lt;segments;i+=1)
        { //((max-min)*value)+min;
            var xx,yy,x1,y1,x2,y2;
            x1 = (((xdrawpos+lengthdir_x(dist,dir))-startx)*(i/segments))+startx;
            y1 = (((ydrawpos+lengthdir_y(dist,dir))-starty)*(i/segments))+starty;
            x2 = ((endx-startx)*(i/segments))+startx;
            y2 = ((endy-starty)*(i/segments))+starty;
            
            xx = ((x2-x1)*(i/segments))+x1;
            yy = ((y2-y1)*(i/segments))+y1;
            draw_line_width_color(lastx,lasty,xx,yy, 5+sin(-(current_time/25)+i), color, color);
            lastx = xx;
            lasty = yy;
        }
        
        draw_line_width_color(lastx,lasty,endx,endy, 5, color, color);
        if (sprite_index != normalSprite) {
            //cancel the fire animation
            sprite_index = normalSprite;
            alarm[6] = 0;
        }
        imageOffset = owner.team+2;
    }
}else{
    if (alarm[6] &lt;= 0){
        //set the sprite to idle
        imageOffset = owner.team
    }else{
        //We are shooting, loop the shoot animation
         imageOffset = floor(image_index mod recoilAnimLength) + recoilAnimLength*owner.team
    }
}


if !owner.player.humiliated draw_sprite_ext(sprite_index,imageOffset, xdrawpos, ydrawpos, image_xscale, image_yscale, image_angle, c_white, 1);
if (owner.ubered) {
    if owner.team == TEAM_RED
        ubercolour = c_red;
    else if owner.team == TEAM_BLUE
        ubercolour = c_blue;
    draw_sprite_ext(sprite_index,imageOffset,round(x+xoffset*image_xscale),round(y+yoffset),image_xscale,image_yscale,image_angle,ubercolour,0.7*image_alpha);
}

</argument>
      </arguments>
    </action>
  </actions>
</event>